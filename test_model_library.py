"""
Test Model Library

This set of tests tries to evaluate all of the various types of models and
model elements that PySD should be able to handle. It does so by executing
the models and comparing their outputs with a set of outputs generated by the
program in which the models were written.

These tests are part of a common system dynamics test suite, that is used by
a number of developers to help develop their own system dynamics tools, and
is available on github at https://github.com/SDXorg/test-models.

The PySD project repository imports these tests as a submodule, and as such the
tests are versioned with the version of the PySD project, so that the two
modules can develop in parallel.

Arguments
---------
-v --verbose : (optional)
    Include this flag to ask for more elaborated error messages
-n --number : int or comma separated list of ints
    Select which tests to run by number

Examples:
To run the full test suite in concise mode:
>>> python test_model_library.py

To run the third test:
>>> python test_model_library.py -n3

To run the third and fifth tests:
>>> python test_model_library.py -n3,5

To run the full test suite in verbose mode:
>>> python test_model_library.py -v

To run test 3 in verbose mode:
>>> python test_model_library.py -v -n3
"""

import glob
import os.path
import traceback
from parsimonious.exceptions import ParseError, IncompleteParseError, VisitationError
import pandas as pd
import pysd
import sys
import timeit
import argparse

# Todo: add option to run only vensim, xmile, or all tests
# Todo: properly format subscript arrays for checking against canonical output

parser = argparse.ArgumentParser()
parser.add_argument('-n','--number', help='which test to run')
parser.add_argument('-v','--verbose', help='displays lots of error messages', action="store_true")
args = parser.parse_args()

#load test models
test_dir = 'tests/test-models/'
vensim_testfiles = glob.glob(test_dir+'*/*/*.mdl')
vensim_testfiles = glob.glob(test_dir+'tests/*/*.mdl')
#xmile_testfiles = glob.glob(test_dir+'*/*/*.xmile')
xmile_testfiles = []
testfiles = {number: testfile for number, testfile in enumerate(vensim_testfiles + xmile_testfiles)}

if args.number:
    numbers = map(int,args.number.split(','))
    testfiles = {int(number): testfiles[int(number)] for number in numbers}


print "Testing module at location: %s\n"%pysd.__file__
err_str = '\n\n'
threshold = 1

success_count = 0
err_count = 0
fail_count = 0

starttime = timeit.time.time()


for i, modelfile in testfiles.iteritems():
    status_str = ''

    try:
        err = None

        # translate and load the model
        if modelfile[-3:] == "mdl":
            model = pysd.read_vensim(modelfile)
            status_str += 'Loaded Model, '
        elif modelfile[-5:] == "xmile":
            model = pysd.read_xmile(modelfile)
            status_str += 'Loaded Model, '

        # load the canonical output
        directory = os.path.dirname(modelfile)
        if os.path.exists(directory+'/output.csv'):
            canon = pd.read_csv(directory+'/output.csv', index_col='Time')
            status_str += 'Loaded canon from .csv, '
        elif os.path.exists(directory+'/output.tab'):
            canon = pd.read_table(directory+'/output.tab', index_col='Time')
            status_str += 'Loaded canon from .tab, '
        else:
            raise IOError('File not found for '+directory+'/output')

        # identify the columns to ask the model for
        #todo: work out how to only ask for the actual model components. Probably by taking away everythign after double __
        pythonized_column_names = [pysd.builder.make_python_identifier(x) for x in canon.columns.tolist()]
        return_columns = list(set([name.split('__')[0] for name in pythonized_column_names]))

        # rename the columns we brought in so they match to the (flattened) model output
        canon.columns = pythonized_column_names
        status_str += 'Looking for output columns: '+', '.join(return_columns)

        # run the model
        output = model.run(return_columns=return_columns,
                           flatten_subscripts=True)
        status_str += 'Ran Model, got columns'+', '.join(output.columns.tolist())

        # check that the canonical output is close to the simulation output
        assert (canon-output).max().max() < 1
        
        print '.',
        success_count += 1
        
    except ParseError as e:
        print 'F',
        
        err_str += '='*60 + '\n'
        err_str += '%i | Test Failure of: %s \n'%(i,modelfile)
        err_str += '-'*60 + '\n'
        err_str += status_str + '\n'
        err_str += 'Parsing Error at line: %i, column%i.\n'%(e.line(), e.column())
        err_str += 'On rule: %s \n\n'%e.expr.__repr__()

        err = e
        fail_count += 1

    except VisitationError as e:
        print 'F',

        err_str += '='*60 + '\n'
        err_str += '%i | Test Failure of: %s \n'%(i,modelfile)
        err_str += '-'*60 + '\n'
        err_str += status_str + '\n'
        err_str += '\n'

        err = e
        fail_count += 1
        
    except IOError as e:
        print 'E',
        
        err_str += '='*60 + '\n'
        err_str += '%i | Test Error attempting: %s \n'%(i,modelfile)
        err_str += '-'*60 + '\n'
        err_str += status_str + '\n'
        err_str += 'Could not load canonical output\n'
        err_str += '\n'

        err = e
        err_count += 1

    except AssertionError as e:
        print 'F',

        err_str += '='*60 + '\n'
        err_str += '%i | Test Failure of: %s \n'%(i,modelfile)
        err_str += '-'*60 + '\n'
        err_str += status_str + '\n'
        err_str += 'Model output does not match canon.\n'
        err_str += 'Variable       Maximum Discrepancy\n'
        err_str += str((canon-output).max())+'\n'
        err_str += '\n'

        fail_count += 1

    except Exception as e:
        print 'E',
        err_str += '='*60 + '\n'
        err_str += '%i | Unknown issue with: %s \n'%(i,modelfile)
        err_str += '-'*60 + '\n'
        err_str += status_str + '\n'
        err_str += '\n'

        err = e
        err_count += 1
    finally:
        if err:
            if args.verbose:
                tb = traceback.format_exc()
                err_str += ''.join(tb)+'\n'


endtime = timeit.time.time()

err_str += '='*60 + '\n'
err_str += 'Attempted %i tests in %.02f seconds \n'%(len(testfiles), (endtime-starttime))
err_str += '%i Successes, %i Failures, %i Errors'%(success_count, fail_count, err_count)

print err_str